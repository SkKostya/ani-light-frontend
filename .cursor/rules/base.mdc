---
alwaysApply: true
---

# Базовые правила разработки проекта

## Технологический стек

### Менеджер пакетов

- **pnpm** - единственный менеджер пакетов для проекта
- Всегда используй `pnpm install`, `pnpm add`, `pnpm remove`
- НЕ используй npm или yarn
- Зависимости должны быть совместимы без флага `--legacy-peer-deps`

### Сборщик

- **rsbuild** - современный сборщик на основе Rspack
- Конфигурация в `rsbuild.config.ts`
- Поддерживает TypeScript, SCSS, SVG из коробки
- Автоматическая оптимизация для production

### Основные технологии

- **React 19** с хуками и функциональными компонентами
- **TypeScript 5.9** с строгой типизацией
- **React Router 7** для маршрутизации
- **Material-UI 7** для UI компонентов
- **Redux Toolkit 2** для глобального состояния
- **i18next** для интернационализации

## Структура проекта

### Архитектура папок

```
src/
├── api/                 # API слой и коннекторы
├── pages/              # Страницы приложения (Страницы могут содержать свои types, hooks, widgets, features, entities, ui которые относятся локально к странице)
├── providers/          # React провайдеры и контексты
├── shared/             # Переиспользуемые компоненты и утилиты
│   ├── constants/      # Константы и перечисления
│   ├── hooks/          # Кастомные хуки
│   ├── services/       # Сервисы и утилиты
│   ├── types/          # TypeScript типы
│   └── ui/             # UI компоненты
├── store/              # Redux store и слайсы
└── styles/             # Глобальные стили
```

### Правила структуры компонентов

- Каждый компонент в отдельной папке с `index.ts`
- Максимум **600 строк** на файл с версткой
- Логика выносится в отдельные хуки или утилиты
- Внутренние компоненты - в подпапки

### Пример структуры компонента

```
shared/ui/my-component/
├── index.ts                    # Экспорт компонента
├── my-component.tsx           # Основной компонент
├── my-component.scss          # Стили компонента
├── my-component.types.ts      # Типы (если нужны)
└── hooks/                     # Локальные хуки
    └── use-my-component.ts
```

## Код и документация

### Документация

- **НЕ создавай** файлы `*.md` (README, документация)
- Код должен быть самодокументированным через семантичные имена
- Функциональные и бизнес-части документируй комментариями
- Все утилиты и хелперы **обязательно** документируй в комментариях

### Именование

- Используй **camelCase** для переменных и функций
- Используй **PascalCase** для компонентов и типов
- Используй **UPPER_SNAKE_CASE** для констант
- Имена должны быть семантически понятными

### Примеры правильного именования

```tsx
// ✅ Хорошо
const userProfile = getUserProfile();
const isLoading = false;
const UserProfileComponent = () => {};
const API_BASE_URL = 'https://api.example.com';

// ❌ Плохо
const up = getUserProfile();
const loading = false;
const UserProfile = () => {};
const apiUrl = 'https://api.example.com';
```

## Типизация

### Строгие правила TypeScript

- **Обязательно** исправляй все ошибки типизации
- **Запрещено** использование `any` без крайней необходимости
- Используй строгую типизацию: `strict: true`
- Все функции должны иметь типы параметров и возвращаемого значения

### Примеры типизации

```tsx
// ✅ Хорошо
interface User {
  id: string;
  name: string;
  email: string;
}

const getUserById = (id: string): Promise<User> => {
  // implementation
};

// ❌ Плохо
const getUserById = (id: any): any => {
  // implementation
};
```

## UI и стилизация

### Material-UI (MUI)

- **Основная** UI библиотека для всех компонентов
- Используй готовые компоненты MUI: `Button`, `TextField`, `Card`, etc.
- Если MUI не покрывает потребности - установи специализированную библиотеку
- Создавай кастомные компоненты только при необходимости

### Темы и цвета

- Проект поддерживает **светлую** и **темную** темы
- **ВСЕ** цвета должны браться из темы: `theme.palette.primary.main`
- Используй CSS переменные из `src/styles/theme-variables.scss`
- **Запрещено** хардкодить цвета в компонентах

### Примеры работы с темами

```tsx
// ✅ Хорошо
<Button sx={{ color: 'primary.main' }}>
  Кнопка
</Button>

<Box sx={{ backgroundColor: 'var(--color-primary)' }}>
  Контент
</Box>

// ❌ Плохо
<Button sx={{ color: '#e91e63' }}>
  Кнопка
</Button>
```

### Организация стилей

#### Правила выбора способа стилизации

- **SCSS файлы** - для сложных стилей с селекторами, псевдоэлементами, анимациями
- **JS объекты стилей** - для простых стилей MUI компонентов с sx prop
- **CSS переменные** - для глобальных значений (цвета, размеры, тени)

#### Структура файлов стилей

```
component/
├── component.tsx           # Основной компонент
├── component.scss          # SCSS стили (если нужны)
├── component.styles.ts     # JS объекты стилей (если нужны)
└── index.ts               # Экспорт компонента
```

#### Правила создания JS объектов стилей

- Создавай файл `component.styles.ts` для каждого компонента с sx стилями
- Используй типизированные объекты с `SxProps<Theme>`
- Группируй стили по элементам: `container`, `header`, `content`, `footer`
- Используй функции для динамических стилей

#### Примеры правильной организации

```tsx
// component.styles.ts
import { SxProps, Theme } from '@mui/material';

export const containerStyles: SxProps<Theme> = {
  display: 'flex',
  flexDirection: 'column',
  minHeight: '100vh',
  backgroundColor: 'var(--color-background)'
};

export const headerStyles: SxProps<Theme> = {
  position: 'sticky',
  top: 0,
  zIndex: 1000,
  backgroundColor: 'var(--color-background-paper)',
  borderBottom: '1px solid var(--color-border)',
  boxShadow: 'var(--shadow-small)'
};

export const getButtonStyles = (isActive: boolean): SxProps<Theme> => ({
  color: isActive ? 'primary.main' : 'text.secondary',
  fontWeight: isActive ? 600 : 400,
  transition: 'all 0.3s ease-in-out',
  '&:hover': {
    color: 'primary.main',
    transform: 'translateY(-2px)'
  }
});
```

```tsx
// component.tsx
import { Box, Button } from '@mui/material';
import { containerStyles, headerStyles, getButtonStyles } from './component.styles';

const MyComponent = ({ isActive }: { isActive: boolean }) => {
  return (
    <Box sx={containerStyles}>
      <Box sx={headerStyles}>
        <Button sx={getButtonStyles(isActive)}>
          Кнопка
        </Button>
      </Box>
    </Box>
  );
};
```

#### Когда использовать SCSS vs JS объекты

**Используй SCSS когда:**
- Нужны сложные селекторы (`.class:hover`, `.parent .child`)
- Псевдоэлементы (`::before`, `::after`)
- Ключевые кадры анимаций (`@keyframes`)
- Медиа-запросы с сложной логикой
- CSS Grid или Flexbox с сложными правилами

**Используй JS объекты когда:**
- Простые стили для MUI компонентов
- Условная стилизация на основе props
- Стили, которые нужно переиспользовать
- Динамические значения из темы

#### Запрещенные практики

```tsx
// ❌ Плохо - сложные стили в sx
<Box sx={{
  '& .nested-element': {
    '&:hover': {
      '&::before': {
        content: '""',
        position: 'absolute',
        // ... много CSS
      }
    }
  }
}}>

// ✅ Хорошо - вынести в SCSS
<Box className="complex-styles">
```

```tsx
// ❌ Плохо - повторяющиеся стили
<Button sx={{ color: 'primary.main', fontWeight: 600 }}>Button 1</Button>
<Button sx={{ color: 'primary.main', fontWeight: 600 }}>Button 2</Button>

// ✅ Хорошо - вынести в JS объект
const buttonStyles = { color: 'primary.main', fontWeight: 600 };
<Button sx={buttonStyles}>Button 1</Button>
<Button sx={buttonStyles}>Button 2</Button>
```

## Адаптивность и мобильная версия

### Приоритет мобильных устройств
- **Основная аудитория** - мобильные устройства (смартфоны, планшеты)
- **Mobile First** подход - сначала разрабатывай мобильную версию
- Мобильная версия должна быть **красивой** и **удобной**
- Все компоненты должны корректно работать на экранах от 320px

### Breakpoints MUI
```tsx
// Используй стандартные breakpoints MUI
const theme = createTheme({
  breakpoints: {
    values: {
      xs: 0,      // мобильные (0-599px)
      sm: 600,    // планшеты (600-899px) 
      md: 900,    // десктоп (900-1199px)
      lg: 1200,   // большой десктоп (1200-1535px)
      xl: 1536    // очень большой экран (1536px+)
    }
  }
});
```

### Правила адаптивности
- **Минимальная ширина**: 320px (iPhone SE)
- **Touch-friendly элементы**: минимум 44px для кнопок и ссылок
- **Отступы**: 16px по бокам на мобильных, 24px на планшетах
- **Шрифты**: читаемые на маленьких экранах (минимум 14px для основного текста)

### Примеры адаптивных компонентов
```tsx
// ✅ Правильно - адаптивная сетка
<Grid container spacing={{ xs: 2, md: 3 }}>
  <Grid item xs={12} sm={6} md={4}>
    <Card>Контент</Card>
  </Grid>
</Grid>

// ✅ Правильно - адаптивные отступы
<Box sx={{ 
  p: { xs: 2, sm: 3, md: 4 },
  mx: { xs: 1, sm: 2, md: 3 }
}}>
  Контент
</Box>

// ✅ Правильно - адаптивная типографика
<Typography variant="h4" sx={{ 
  fontSize: { xs: '1.5rem', sm: '2rem', md: '2.5rem' }
}}>
  Заголовок
</Typography>
```

### Мобильная навигация
- Используй **Bottom Navigation** или **Drawer** для мобильных
- Главное меню должно быть доступно одним касанием
- Показывай активную страницу в навигации
- Используй иконки с подписями для лучшего UX

### Touch-взаимодействие
- **Минимальный размер** интерактивных элементов: 44x44px
- Добавляй **достаточные отступы** между кнопками (минимум 8px)
- Используй **swipe-жесты** где это уместно
- **Отключай hover-эффекты** на мобильных устройствах

### Адаптивные изображения
```tsx
// ✅ Правильно - адаптивные изображения
<Box
  component="img"
  src="/image-mobile.jpg"
  sx={{
    width: '100%',
    height: { xs: 200, sm: 300, md: 400 },
    objectFit: 'cover'
  }}
/>

// ✅ Правильно - разные изображения для разных экранов
<picture>
  <source media="(min-width: 900px)" srcSet="/image-desktop.jpg" />
  <source media="(min-width: 600px)" srcSet="/image-tablet.jpg" />
  <img src="/image-mobile.jpg" alt="Описание" />
</picture>
```

### Производительность на мобильных
- **Оптимизируй изображения** (WebP, сжатие)
- Используй **ленивую загрузку** для тяжелых компонентов
- **Минимизируй** количество HTTP запросов
- **Кэшируй** статические ресурсы

### Тестирование адаптивности
- Тестируй на **реальных устройствах**, а не только в DevTools
- Проверяй на **медленных соединениях** (3G)
- Тестируй **разные ориентации** экрана
- Проверяй **accessibility** на мобильных

### Адаптивные паттерны
```tsx
// ✅ Правильно - адаптивная карточка
<Card sx={{
  width: { xs: '100%', sm: 'calc(50% - 8px)', md: 'calc(33.333% - 12px)' },
  mb: { xs: 2, sm: 3 }
}}>
  <CardContent sx={{ p: { xs: 2, sm: 3 } }}>
    <Typography variant="h6" sx={{ 
      fontSize: { xs: '1.1rem', sm: '1.25rem' },
      mb: { xs: 1, sm: 2 }
    }}>
      Заголовок
    </Typography>
  </CardContent>
</Card>

// ✅ Правильно - адаптивная форма
<Stack spacing={{ xs: 2, sm: 3 }}>
  <TextField
    fullWidth
    size={useMediaQuery(theme.breakpoints.down('sm')) ? 'small' : 'medium'}
    label="Email"
  />
  <Button
    fullWidth
    size={useMediaQuery(theme.breakpoints.down('sm')) ? 'large' : 'medium'}
    variant="contained"
  >
    Отправить
  </Button>
</Stack>
```

### Мобильные особенности
- **Портретная ориентация** - основной режим просмотра
- **Большие пальцы** - учитывай при размещении элементов
- **Одна рука** - важные действия должны быть доступны одной рукой
- **Быстрый доступ** - часто используемые функции должны быть на виду

## Управление состоянием

### Redux Toolkit

- **Основной** способ управления глобальным состоянием
- Используй вместо `useContext` для глобальных данных
- Всегда используй типизированные хуки: `useAppDispatch` и `useAppSelector`

### Импорты Redux

```tsx
// ✅ Правильно
import { setTheme, toggleTheme } from '@/store/app.slice';
import { useAppDispatch, useAppSelector } from '@/store/store';

// ❌ Неправильно
import { useDispatch, useSelector } from 'react-redux';
```

### Структура слайсов

```tsx
// Пример правильного слайса
const mySlice = createSlice({
  name: 'myFeature',
  initialState,
  reducers: {
    setValue: (state, action: PayloadAction<string>) => {
      state.value = action.payload;
    }
  }
});
```

## Стили и SCSS

### Организация стилей

- Глобальные стили в `src/styles/`
- Стили компонентов рядом с компонентом
- Используй SCSS для сложной стилизации
- CSS переменные для цветов и размеров

### Именование классов

```scss
// ✅ Хорошо - BEM методология
.my-component {
  &__header {
    // стили заголовка
  }

  &--active {
    // модификатор
  }
}

// ❌ Плохо
.myComponent {
  .header {
    // стили
  }
}
```

## API и данные

### Структура API

- API коннекторы в `src/api/`
- Используй `axios` для HTTP запросов
- Типизируй все API ответы
- Обрабатывай ошибки корректно

### Пример API коннектора

```tsx
// api/user.api.ts
interface UserResponse {
  id: string;
  name: string;
  email: string;
}

export const userApi = {
  getUser: (id: string): Promise<UserResponse> => {
    return axios.get(`/api/users/${id}`);
  }
};
```

## Производительность

### Оптимизация компонентов

- Используй `React.memo` для предотвращения лишних рендеров
- Используй `useMemo` и `useCallback` для дорогих вычислений
- Избегай создания объектов в render функции

### Ленивая загрузка

```tsx
// Ленивая загрузка страниц
const LazyPage = lazy(() => import('./pages/MyPage'));

// Использование
<Suspense fallback={<Loader />}>
  <LazyPage />
</Suspense>;
```

## Обработка ошибок

### Error Boundaries

- Используй `react-error-boundary` для обработки ошибок
- Создавай fallback UI для критических ошибок
- Логируй ошибки для отладки

### Валидация

- Валидируй данные на входе в компоненты
- Используй TypeScript для статической проверки
- Обрабатывай ошибки API запросов

## Тестирование

### Структура тестов

- Тесты рядом с тестируемыми файлами: `component.test.tsx`
- Используй описательные имена тестов
- Покрывай критическую функциональность

## Git и коммиты

### Pre-commit хуки

- Автоматический линтинг и форматирование
- Проверка типов TypeScript
- Проверка стилей SCSS

### Сообщения коммитов

- Используй понятные сообщения на русском языке
- Указывай тип изменений: `feat:`, `fix:`, `refactor:`
- Пример: `feat: добавить компонент каталога аниме`

## Отладка и разработка

### Консоль

- Используй `console.log`, `console.warn`, `console.error` для отладки
- НЕ оставляй `console.log` в production коде
- Используй React DevTools для отладки состояния

### Линтеры

- ESLint для JavaScript/TypeScript
- Stylelint для SCSS
- Prettier для форматирования
- Все ошибки линтеров должны быть исправлены

---
alwaysApply: true
---

# Базовые правила разработки проекта

## Технологический стек

### Менеджер пакетов

- **pnpm** - единственный менеджер пакетов для проекта
- Всегда используй `pnpm install`, `pnpm add`, `pnpm remove`
- НЕ используй npm или yarn
- Зависимости должны быть совместимы без флага `--legacy-peer-deps`

### Сборщик

- **rsbuild** - современный сборщик на основе Rspack
- Конфигурация в `rsbuild.config.ts`
- Поддерживает TypeScript, SCSS, SVG из коробки
- Автоматическая оптимизация для production

### Основные технологии

- **React 19** с хуками и функциональными компонентами
- **TypeScript 5.9** с строгой типизацией
- **React Router 7** для маршрутизации
- **Material-UI 7** для UI компонентов
- **Redux Toolkit 2** для глобального состояния
- **i18next** для интернационализации

## Структура проекта

### Архитектура папок

```
src/
├── api/                 # API слой и коннекторы
├── pages/              # Страницы приложения
├── providers/          # React провайдеры и контексты
├── shared/             # Переиспользуемые компоненты и утилиты
│   ├── constants/      # Константы и перечисления
│   ├── hooks/          # Кастомные хуки
│   ├── services/       # Сервисы и утилиты
│   ├── types/          # TypeScript типы
│   └── ui/             # UI компоненты
├── store/              # Redux store и слайсы
└── styles/             # Глобальные стили
```

### Правила структуры компонентов

- Каждый компонент в отдельной папке с `index.ts`
- Максимум **600 строк** на файл с версткой
- Логика выносится в отдельные хуки или утилиты
- Внутренние компоненты - в подпапки

### Пример структуры компонента

```
shared/ui/my-component/
├── index.ts                    # Экспорт компонента
├── my-component.tsx           # Основной компонент
├── my-component.scss          # Стили компонента
├── my-component.types.ts      # Типы (если нужны)
└── hooks/                     # Локальные хуки
    └── use-my-component.ts
```

## Код и документация

### Документация

- **НЕ создавай** файлы `*.md` (README, документация)
- Код должен быть самодокументированным через семантичные имена
- Функциональные и бизнес-части документируй комментариями
- Все утилиты и хелперы **обязательно** документируй в комментариях

### Именование

- Используй **camelCase** для переменных и функций
- Используй **PascalCase** для компонентов и типов
- Используй **UPPER_SNAKE_CASE** для констант
- Имена должны быть семантически понятными

### Примеры правильного именования

```tsx
// ✅ Хорошо
const userProfile = getUserProfile();
const isLoading = false;
const UserProfileComponent = () => {};
const API_BASE_URL = 'https://api.example.com';

// ❌ Плохо
const up = getUserProfile();
const loading = false;
const UserProfile = () => {};
const apiUrl = 'https://api.example.com';
```

## Типизация

### Строгие правила TypeScript

- **Обязательно** исправляй все ошибки типизации
- **Запрещено** использование `any` без крайней необходимости
- Используй строгую типизацию: `strict: true`
- Все функции должны иметь типы параметров и возвращаемого значения

### Примеры типизации

```tsx
// ✅ Хорошо
interface User {
  id: string;
  name: string;
  email: string;
}

const getUserById = (id: string): Promise<User> => {
  // implementation
};

// ❌ Плохо
const getUserById = (id: any): any => {
  // implementation
};
```

## UI и стилизация

### Material-UI (MUI)

- **Основная** UI библиотека для всех компонентов
- Используй готовые компоненты MUI: `Button`, `TextField`, `Card`, etc.
- Если MUI не покрывает потребности - установи специализированную библиотеку
- Создавай кастомные компоненты только при необходимости

### Темы и цвета

- Проект поддерживает **светлую** и **темную** темы
- **ВСЕ** цвета должны браться из темы: `theme.palette.primary.main`
- Используй CSS переменные из `src/styles/theme-variables.scss`
- **Запрещено** хардкодить цвета в компонентах

### Примеры работы с темами

```tsx
// ✅ Хорошо
<Button sx={{ color: 'primary.main' }}>
  Кнопка
</Button>

<Box sx={{ backgroundColor: 'var(--color-primary)' }}>
  Контент
</Box>

// ❌ Плохо
<Button sx={{ color: '#e91e63' }}>
  Кнопка
</Button>
```

## Управление состоянием

### Redux Toolkit

- **Основной** способ управления глобальным состоянием
- Используй вместо `useContext` для глобальных данных
- Всегда используй типизированные хуки: `useAppDispatch` и `useAppSelector`

### Импорты Redux

```tsx
// ✅ Правильно
import { setTheme, toggleTheme } from '@/store/app.slice';
import { useAppDispatch, useAppSelector } from '@/store/store';

// ❌ Неправильно
import { useDispatch, useSelector } from 'react-redux';
```

### Структура слайсов

```tsx
// Пример правильного слайса
const mySlice = createSlice({
  name: 'myFeature',
  initialState,
  reducers: {
    setValue: (state, action: PayloadAction<string>) => {
      state.value = action.payload;
    }
  }
});
```

## Стили и SCSS

### Организация стилей

- Глобальные стили в `src/styles/`
- Стили компонентов рядом с компонентом
- Используй SCSS для сложной стилизации
- CSS переменные для цветов и размеров

### Именование классов

```scss
// ✅ Хорошо - BEM методология
.my-component {
  &__header {
    // стили заголовка
  }

  &--active {
    // модификатор
  }
}

// ❌ Плохо
.myComponent {
  .header {
    // стили
  }
}
```

## API и данные

### Структура API

- API коннекторы в `src/api/`
- Используй `axios` для HTTP запросов
- Типизируй все API ответы
- Обрабатывай ошибки корректно

### Пример API коннектора

```tsx
// api/user.api.ts
interface UserResponse {
  id: string;
  name: string;
  email: string;
}

export const userApi = {
  getUser: (id: string): Promise<UserResponse> => {
    return axios.get(`/api/users/${id}`);
  }
};
```

## Производительность

### Оптимизация компонентов

- Используй `React.memo` для предотвращения лишних рендеров
- Используй `useMemo` и `useCallback` для дорогих вычислений
- Избегай создания объектов в render функции

### Ленивая загрузка

```tsx
// Ленивая загрузка страниц
const LazyPage = lazy(() => import('./pages/MyPage'));

// Использование
<Suspense fallback={<Loader />}>
  <LazyPage />
</Suspense>;
```

## Обработка ошибок

### Error Boundaries

- Используй `react-error-boundary` для обработки ошибок
- Создавай fallback UI для критических ошибок
- Логируй ошибки для отладки

### Валидация

- Валидируй данные на входе в компоненты
- Используй TypeScript для статической проверки
- Обрабатывай ошибки API запросов

## Тестирование

### Структура тестов

- Тесты рядом с тестируемыми файлами: `component.test.tsx`
- Используй описательные имена тестов
- Покрывай критическую функциональность

## Git и коммиты

### Pre-commit хуки

- Автоматический линтинг и форматирование
- Проверка типов TypeScript
- Проверка стилей SCSS

### Сообщения коммитов

- Используй понятные сообщения на русском языке
- Указывай тип изменений: `feat:`, `fix:`, `refactor:`
- Пример: `feat: добавить компонент каталога аниме`

## Отладка и разработка

### Консоль

- Используй `console.log`, `console.warn`, `console.error` для отладки
- НЕ оставляй `console.log` в production коде
- Используй React DevTools для отладки состояния

### Линтеры

- ESLint для JavaScript/TypeScript
- Stylelint для SCSS
- Prettier для форматирования
- Все ошибки линтеров должны быть исправлены
